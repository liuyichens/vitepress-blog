---
title: JavaScript的内存管理和闭包
date: 2022-10-18 07:35:05
permalink: /pages/7a5554/
categories:
  - JavaScript
tags:
  - 内存管理
  - 闭包
author: 
  name: 柳逸尘
---

## 内存管理

在任何编程语言的代码执行过程中都是需要给他分配内存的，某些编程语言要自己手动管理内存，某些编程语言可以自动管理内存。

内存的管理都存在生命周期
- 分配申请需要的内存(申请)
- 使用分配的内存(存放一些东西，例如对象等)
- 不需要使用时，对其进行释放

对于开发者来说，JavaScript的内存管理是自动的、无形的。例如创建的原始值，对象，函数...这一切都会占用内存，不需要手动进行管理，JavaScript引擎会自动处理。



手动管理内存的语言：C、C++以及早期的OC (malloc和free函数)

自动管理内存的语言：Java、JavaScript、Python等。



## JavaScript的内存管理

JavaScript会在定义数据时分配内存

JS对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配。

JS对于复杂的数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用。

![image](https://cdn.statically.io/gh/liuyichens/blog_img@main/image.7fa7pps0ysw0.webp)

## JavaScript的内存回收

内存的大小是有限的，当内存不再需要的时候，需要对其进行释放，腾出更多的内存空间。

手动管理内存的语言中，通过一些方式自己来释放不再需要的内存，比如free函数：

- 这种管理的方式非常低效，影响编写逻辑的代码的效率；
- 且这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露

大部分现代的编程语言都是有自己的垃圾回收机制

- **垃圾回收**的英文是Garbage Collection，简称GC
- 对于那些不再使用的对象，都称之为是垃圾，它需要被回收，以释放更多的内存空间
- 比如Java的运行环境JVM，JavaScript的运行环境js引擎都会使用垃圾回收器

## 常见的GC算法

GC怎么知道哪些对象是不再使用的呢？就要用到GC的实现以及对应的算法

### 引用计数(Reference counting)

- 当一个对象有一个引用指向它时，那么这个对象的引用就+1；
- 当一个对象的引用为0时，这个对象就可以被销毁掉；

- 这个算法有一个很大的弊端就是会产生循环引用

### 标记清除 (mark-sweep)

- 标记清除的核心思路是**可达性**（Reachability）
- 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象；
- 这个算法可以很好的解决循环引用的问题

### 其它算法

**JS引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其他的算法**

#### 标记整理（Mark-Compact） 

- 和“标记－清除”相似
- 不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化

#### 分代收集（Generational collection）

- 对象被分成两组：“新的”和“旧的”。
- 许多对象出现，完成它们的工作并很快死去，它们可以很快被清理
- 那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少

#### 增量收集（Incremental collection）

- 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟
- 所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟；

#### 闲时收集（Idle-time collection）

- 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

**这些算法的目的都是为了让垃圾回收的效率更高**



## 闭包

### 闭包的定义

在计算机科学中对于闭包的定义

- 闭包(closure)又称之为**词法闭包**或者**函数闭包**
- 是在支持头等函数的编程语言中实现词法绑定的一种技术
- 闭包在实现上是一个结构体，存储了**一个函数和一个关联环境**
- 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；

MDN对JavaScript闭包的解释

- 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；
- 闭包让你可以在一个内层函数中访问到其外层函数的作用域；
- 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来

总结

- 一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包；
- 从广义的角度来说：JavaScript中的函数都是闭包；
- 从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；

### 闭包的访问过程

```js
function createAdder(count) {
  function adder(num) {
    return count + num;
  }
  return adder;
}
var adder5 = createAdder(5);
adder5(10); // 15
var adder10 = createAdder(10);
adder10(6); // 16
```

### 闭包的执行过程

- 这个时候makeAdder函数执行完毕，正常情况下我们的AO对象会被释放；
- 但是因为在0xb00的函数中有作用域引用指向了这个AO对象，所以它不会被释放掉；

![image](https://cdn.statically.io/gh/liuyichens/blog_img@main/image.74f45dqui8g0.webp)

### 闭包的内存泄漏

在上面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父作用域AO也应该被销毁掉

但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引用，所以最终会造成这些内存都是无法被释放的

所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的；

#### 解决内存泄漏问题

设置 adder10 = null

因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了；

在GC的下一次检测中，它们就会被销毁掉；
